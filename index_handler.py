from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from search_handler import send_books_page
from search_handler import normalize_text, remove_common_words
import re

INDEXES = [
    ("Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "arabic_grammar", ["Ù‚ÙˆØ§Ø¹Ø¯", "Ù†Ø­Ùˆ", "ØµØ±Ù", "Ø¥Ù…Ù„Ø§Ø¡", "Ù„ØºÙˆÙŠ"]),
    ("ÙƒØªØ¨ Ø¥Ù†ÙƒÙ„ÙŠØ²ÙŠØ©", "english_books", ["english", "grammar", "literature", "novel"]),
    ("Ø§Ù„Ø¨Ø±Ù…Ø¬Ø©", "programming", ["Ø¨Ø±Ù…Ø¬Ø©", "ÙƒÙˆØ¯", "python", "java", "algorithm"]),
    # Ø£Ø¶Ù Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙÙ‡Ø§Ø±Ø³ Ù‡Ù†Ø§...
]

def normalize_keywords(keywords):
    return [normalize_text(remove_common_words(k)) for k in keywords]

async def show_index(update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton(name, callback_data=f"index:{key}")] for name, key, _ in INDEXES]
    reply_markup = InlineKeyboardMarkup(keyboard)
    query = update.callback_query
    await query.answer()
    await query.message.reply_text("ğŸ“š Ø§Ø®ØªØ± Ø§Ù„ÙÙ‡Ø±Ø³ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ø³ØªØ¹Ø±Ø§Ø¶Ù‡:", reply_markup=reply_markup)

async def search_by_index(update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    index_key = query.data.replace("index:", "")

    conn = context.bot_data.get("db_conn")
    if not conn:
        await query.message.reply_text("âŒ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØµÙ„Ø© Ø­Ø§Ù„ÙŠØ§Ù‹.")
        return

    keywords = []
    for name, key, kws in INDEXES:
        if key == index_key:
            keywords = kws
            break
    if not keywords:
        await query.message.reply_text("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙÙ‡Ø±Ø³.")
        return

    keywords = normalize_keywords(keywords)
    or_conditions = " OR ".join([f"LOWER(file_name) LIKE '%{k}%'" for k in keywords])
    try:
        books = await conn.fetch(f"""
            SELECT id, file_id, file_name, uploaded_at
            FROM books
            WHERE {or_conditions}
            ORDER BY uploaded_at DESC;
        """)
    except:
        await query.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒØªØ¨.")
        return

    if not books:
        await query.message.reply_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ ÙƒØªØ¨ Ø¶Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„ÙÙ‡Ø±Ø³.")
        return

    context.user_data["search_results"] = [dict(b) for b in books]
    context.user_data["current_page"] = 0
    context.user_data["search_stage"] = f"ÙÙ‡Ø±Ø³: {index_key}"

    await send_books_page(update, context)
